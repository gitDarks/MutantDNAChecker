{"version":3,"file":"/Users/drodr25/Desktop/MutantDNAChecker/src/modules/core/services/db/db.service.ts","sources":["/Users/drodr25/Desktop/MutantDNAChecker/src/modules/core/services/db/db.service.ts"],"names":[],"mappings":"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","sourcesContent":["import \"reflect-metadata\";\nimport { getVariable } from \"../../../../config\";\nimport { DNASequencesEntity } from \"../../entities/sequence.entity\";\nimport {\n  Connection,\n  createConnection,\n  getConnectionManager,\n  QueryRunner,\n} from \"typeorm\";\n\nexport class ConnectionDB {\n  public static async getConnectionInstance(): Promise<ConnectionDB> {\n    ConnectionDB.concurrentCalleds++;\n    console.log(\n      \"CONCURRENT CALLEDS ON START CONNECTION %s\",\n      ConnectionDB.concurrentCalleds\n    );\n    console.log(\"[START] %o\", ConnectionDB.connectionInstance);\n    const connectionManager = await getConnectionManager();\n    if (connectionManager.connections.length > 0) {\n      const aliveConnection = connectionManager.get(\"default\");\n      if (aliveConnection.isConnected) {\n        console.log(\n          \"[INFO] ALIVE-CONNECTION => %o\",\n          aliveConnection.isConnected\n        );\n        ConnectionDB.connection = await aliveConnection;\n      } else {\n        ConnectionDB.restoreSingleton();\n      }\n      console.log(\"SETTED OF EXISTENT CONNECTION\");\n    }\n\n    if (!ConnectionDB.connectionInstance) {\n      try {\n        ConnectionDB.connectionInstance = new ConnectionDB();\n        ConnectionDB.connection = await ConnectionDB.runConnection();\n        console.log(\"FINISH CREATE CONNECTION\");\n      } catch (error) {\n        console.log(\"ERROR ON GET CONNECTION %O\", error);\n        ConnectionDB.restoreSingleton();\n        throw new Error(\"ERROR ON GET CONNECTION\");\n      }\n    }\n\n    return ConnectionDB.connectionInstance;\n  }\n\n  public static async getQueryRunner(): Promise<QueryRunner> {\n    return ConnectionDB.connection.createQueryRunner();\n  }\n\n  public static async getConnection(): Promise<Connection> {\n    return ConnectionDB.connection;\n  }\n\n  public static async startTransaction(queryRunner: QueryRunner): Promise<any> {\n    await queryRunner.startTransaction();\n  }\n\n  public static async commitTransaction(\n    queryRunner: QueryRunner\n  ): Promise<any> {\n    await queryRunner.commitTransaction();\n    await queryRunner.release();\n  }\n\n  public static async rollbackTransaction(\n    queryRunner: QueryRunner\n  ): Promise<any> {\n    await queryRunner.rollbackTransaction();\n  }\n\n  public static async closeConnection(): Promise<any> {\n    console.log(`[DB START CLOSING CONNECTION]`);\n    try {\n      console.log(\n        \"CONCURRENT CALLEDS on CLOSE CONNECTION %s\",\n        ConnectionDB.concurrentCalleds\n      );\n      if (ConnectionDB.concurrentCalleds <= 1) {\n        if (Object.keys(ConnectionDB.connection).length > 0) {\n          const connection = await ConnectionDB.getConnection();\n          await connection.close();\n          ConnectionDB.restoreSingleton();\n          console.log(\n            \"[INFO] CLOSED CONNECTION, CONNECTIONDB => %o\",\n            ConnectionDB.connectionInstance\n          );\n        } else {\n          console.log(\n            \"[WARNING]CANNOT CLOSE CONNECTION OF INEXISTENT ATTRIBUTE, CONNECTIONDB => %o\",\n            ConnectionDB\n          );\n        }\n      } else {\n        ConnectionDB.concurrentCalleds--;\n        if (ConnectionDB.concurrentCalleds === 1) {\n          await ConnectionDB.closeConnection();\n        }\n      }\n    } catch (error) {\n      console.log(\"[ERROR]Error in closeConnection %o\", error);\n    }\n  }\n\n  public static restoreSingleton(): void {\n    ConnectionDB.connectionInstance = null;\n    ConnectionDB.concurrentCalleds = 0;\n    ConnectionDB.connection = {} as Connection;\n  }\n\n  private static connectionInstance: ConnectionDB | null;\n  private static connection: Connection;\n  private static concurrentCalleds = 0;\n  private static async runConnection(): Promise<Connection> {\n    try {\n\n      const rc = await createConnection({\n        acquireTimeout: Number(await getVariable(\"DATABASE_TIMEOUT\")),\n        connectTimeout: Number(await getVariable(\"DATABASE_TIMEOUT\")),\n        database: await getVariable(\"DB_NAME\"),\n        host: await getVariable(\"DB_HOST\"),\n        password: await getVariable(\"DB_PASSWORD\"),\n        port: +(await getVariable(\"DB_PORT\")),\n        username: await getVariable(\"DB_USER\"),\n        entities: [DNASequencesEntity],\n        extra: {\n          connectionLimit: 300,\n        },\n        synchronize: false,\n        type: \"mysql\",\n      });\n      return rc;\n    } catch (error) {\n      console.log(`[ERROR-DB] ${error}`);\n      return Promise.reject({\n        message: \"Could not connect to DB\",\n        error: `${error}`,\n      });\n    }\n  }\n}\n"]}